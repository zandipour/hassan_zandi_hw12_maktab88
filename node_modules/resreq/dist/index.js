// src/constants/index.ts
var ON_GLOBAL_DOWNLOAD_PROGRESS = Symbol("ON_GLOBAL_DOWNLOAD_PROGRESS");
var ABORT_CONTROLLER = Symbol("ABORT_CONTROLLER");

// src/helpers/compose.ts
var compose = (...funcs) => {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(
    (a, b) => (...args) => a(b(...args))
  );
};
var compose_default = compose;

// src/helpers/isJsonBody.ts
var isJsonBody = (body) => {
  return body && typeof body === "object" && !(globalThis.FormData && body instanceof FormData || globalThis.Blob && body instanceof Blob || globalThis.File && body instanceof File || globalThis.ArrayBuffer && body instanceof ArrayBuffer || globalThis.ArrayBuffer && ArrayBuffer.isView(body) || globalThis.URLSearchParams && body instanceof URLSearchParams || globalThis.ReadableStream && body instanceof ReadableStream);
};
var isJsonBody_default = isJsonBody;

// package.json
var version = "1.2.1";

// src/Req.ts
var Req = class extends Request {
  meta;
  timeout;
  responseType;
  throwHttpError;
  [ABORT_CONTROLLER];
  onDownloadProgress;
  [ON_GLOBAL_DOWNLOAD_PROGRESS];
  constructor(request, init) {
    let body = init.body ?? request.body;
    const headers = new Headers(init.headers ?? request.headers);
    !headers.has("User-Agent") && headers.set("User-Agent", `resreq/${version}`);
    if (body && isJsonBody_default(body)) {
      headers.set("Content-Type", "application/json");
      try {
        body = JSON.stringify(body);
      } catch (error) {
        throw new TypeError(`Request body must be a valid JSON object.`);
      }
    }
    if (globalThis.FormData && body instanceof FormData || body instanceof URLSearchParams) {
      headers.delete("Content-Type");
    }
    const abortController = new AbortController();
    const signal = init.signal || request.signal || abortController.signal;
    super(new Request(init.url ?? request.url), {
      method: init.method ?? request.method,
      headers,
      body: body ?? request.body,
      mode: init.mode ?? request.mode,
      credentials: init.credentials ?? request.credentials,
      cache: init.cache ?? request.cache,
      redirect: init.redirect ?? request.redirect,
      referrer: init.referrer ?? request.referrer,
      referrerPolicy: init.referrerPolicy ?? request.referrerPolicy,
      integrity: init.integrity ?? request.integrity,
      keepalive: init.keepalive ?? request.keepalive,
      signal: abortController.signal
    });
    this.meta = init.meta ?? request.meta;
    this.timeout = init.timeout ?? request.timeout;
    this.responseType = init.responseType ?? request.responseType;
    this.throwHttpError = init.throwHttpError ?? request.throwHttpError;
    this.onDownloadProgress = init.onDownloadProgress ?? request.onDownloadProgress;
    this[ON_GLOBAL_DOWNLOAD_PROGRESS] = init[ON_GLOBAL_DOWNLOAD_PROGRESS] ?? request[ON_GLOBAL_DOWNLOAD_PROGRESS];
    this[ABORT_CONTROLLER] = abortController;
    signal.addEventListener("abort", () => abortController.abort());
  }
};

// src/middleware/requestHandler.ts
var requestHandler = (next) => async (_req) => {
  const req = _req;
  const url = Object.entries(req.params || {}).reduce(
    (acc, [key, value]) => {
      acc.searchParams.append(key, value);
      return acc;
    },
    req.baseURL ? new URL(req.url, req.baseURL) : new URL(req.url)
  ).toString();
  return await next(new Req(req, { url }));
};
var requestHandler_default = requestHandler;

// src/Res.ts
var Res = class extends Response {
  meta;
  timeout;
  responseType;
  throwHttpError;
  abortController;
  onDownloadProgress;
  [ON_GLOBAL_DOWNLOAD_PROGRESS];
  constructor(response, init) {
    let body = init.body ?? response.body;
    const headers = new Headers(init.headers ?? response.headers);
    if (body && isJsonBody_default(body)) {
      try {
        body = JSON.stringify(body);
      } catch (error) {
        throw new TypeError(`Response body must be a valid JSON object.`);
      }
    }
    super(body, {
      status: init.status ?? response.status,
      statusText: init.statusText ?? response.statusText,
      headers
    });
    this.meta = init.meta ?? response.meta;
    this.timeout = init.timeout ?? response.timeout;
    this.responseType = init.responseType ?? response.responseType;
    this.throwHttpError = init.throwHttpError ?? response.throwHttpError;
    this.abortController = init[ABORT_CONTROLLER] ?? response.abortController;
    this.onDownloadProgress = init.onDownloadProgress ?? response.onDownloadProgress;
    this[ON_GLOBAL_DOWNLOAD_PROGRESS] = init[ON_GLOBAL_DOWNLOAD_PROGRESS] ?? response[ON_GLOBAL_DOWNLOAD_PROGRESS];
  }
};

// src/middleware/responseHandler.ts
var createReadableStream = (response, onDownloadProgress) => new ReadableStream({
  async start(controller) {
    const total = +response.headers.get("content-length") || 0;
    if (!response.body?.getReader) {
      return controller.close();
    }
    const reader = response.body.getReader();
    let carry = 0;
    onDownloadProgress(
      {
        ratio: 0,
        carry: 0,
        total: 0
      },
      new Uint8Array()
    );
    const read = async () => {
      const { done, value } = await reader.read();
      if (done)
        return controller.close();
      carry += value.byteLength;
      onDownloadProgress(
        {
          ratio: carry / total * 100,
          carry,
          total
        },
        value
      );
      controller.enqueue(value);
      await read();
    };
    await read();
  }
});
var responseHandler = (next) => async (req) => {
  const response = await next(req);
  if (req.throwHttpError && !response.ok) {
    throw new Error(`${response.status} ${response.statusText}`);
  }
  createReadableStream(response.clone(), (...args) => {
    req.onDownloadProgress?.(...args);
    req[ON_GLOBAL_DOWNLOAD_PROGRESS]?.(...args);
  });
  return new Res(response, { ...req });
};
var responseHandler_default = responseHandler;

// src/middleware/timeoutHandler.ts
var timeoutHandler = (next) => async (req) => {
  return await new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      req[ABORT_CONTROLLER].abort();
      reject(new Error(`Network timeout at: ${req.url}`));
    }, req.timeout || 2147483647);
    void next(req).then(resolve).catch(reject).then(() => clearTimeout(timer));
  });
};
var timeoutHandler_default = timeoutHandler;

// src/middleware/responseTypeHandler.ts
var responseTypeHandler = (next) => async (req) => {
  const res = await next(req);
  return req.responseType ? await res[req.responseType]() : res;
};
var responseTypeHandler_default = responseTypeHandler;

// src/helpers/mergeHeaders.ts
var mergeHeaders = (target, source) => {
  const targetHeaders = Object.fromEntries(new Headers(target).entries());
  const sourceHeaders = Object.fromEntries(new Headers(source).entries());
  return new Headers({ ...targetHeaders, ...sourceHeaders });
};
var mergeHeaders_default = mergeHeaders;

// src/index.ts
var Resreq = class {
  options;
  middleware = [responseTypeHandler_default, requestHandler_default, timeoutHandler_default, responseHandler_default];
  constructor(options = {}) {
    this.options = {
      ...options,
      baseURL: options.baseURL || "",
      timeout: options.timeout || 1e3,
      throwHttpError: options.throwHttpError || false
    };
  }
  use(middleware) {
    const responseHandler2 = this.middleware.pop();
    const timeoutHandler2 = this.middleware.pop();
    this.middleware = [...this.middleware, ...[middleware].flat(), timeoutHandler2, responseHandler2];
    return this;
  }
  async request(options) {
    const dispatch = compose_default(...this.middleware);
    return dispatch(fetch)({
      ...this.options,
      ...options,
      headers: mergeHeaders_default(this.options.headers || {}, options?.headers || {}),
      onDownloadProgress: options.onDownloadProgress,
      [ON_GLOBAL_DOWNLOAD_PROGRESS]: this.options.onDownloadProgress
    });
  }
  async get(url, options) {
    return await this.request({ ...options, url, method: "GET" });
  }
  async post(url, options) {
    return await this.request({ ...options, url, method: "POST" });
  }
  async put(url, options) {
    return await this.request({ ...options, url, method: "PUT" });
  }
  async delete(url, options) {
    return await this.request({ ...options, url, method: "DELETE" });
  }
  async patch(url, options) {
    return await this.request({ ...options, url, method: "PATCH" });
  }
  async head(url, options) {
    return await this.request({ ...options, url, method: "HEAD" });
  }
};
export {
  Req,
  Res,
  Resreq as default,
  mergeHeaders_default as mergeHeaders
};
//# sourceMappingURL=index.js.map