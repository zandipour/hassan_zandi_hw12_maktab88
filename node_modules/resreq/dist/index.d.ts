declare const ON_GLOBAL_DOWNLOAD_PROGRESS: unique symbol;
declare const ABORT_CONTROLLER: unique symbol;

declare class Req extends Request {
    readonly meta?: Record<string, any>;
    readonly timeout: number;
    readonly responseType?: ResponseType;
    readonly throwHttpError: boolean;
    readonly [ABORT_CONTROLLER]: AbortController;
    readonly onDownloadProgress?: ProgressCallback;
    readonly [ON_GLOBAL_DOWNLOAD_PROGRESS]?: ProgressCallback;
    constructor(request: Req, init: ReqInit | Request);
}

declare class Res extends Response {
    readonly meta?: Record<string, any>;
    readonly timeout: number;
    readonly responseType?: ResponseType;
    readonly throwHttpError: boolean;
    readonly abortController: AbortController;
    readonly onDownloadProgress?: ProgressCallback;
    readonly [ON_GLOBAL_DOWNLOAD_PROGRESS]?: ProgressCallback;
    constructor(response: Res, init: ResInit | Response);
}

interface ResInit extends ResponseInit {
    meta?: Record<string, any>;
    body?: BodyInit | Record<string, any> | null;
    timeout?: number;
    responseType?: ResponseType;
    throwHttpError?: boolean;
    [ABORT_CONTROLLER]?: AbortController;
    onDownloadProgress?: ProgressCallback;
    [ON_GLOBAL_DOWNLOAD_PROGRESS]?: ProgressCallback;
}
interface ReqInit extends Omit<RequestInit, 'body'> {
    url?: string;
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH';
    meta?: Record<string, any>;
    timeout?: number;
    /**
     * This should be consistent with the parsing method of Response
     */
    responseType?: ResponseType;
    throwHttpError?: boolean;
    body?: BodyInit | Record<string, any>;
    onDownloadProgress?: ProgressCallback;
    [ON_GLOBAL_DOWNLOAD_PROGRESS]?: ProgressCallback;
}
type Next = (req: Req) => Promise<Res>;
type Middleware = (next: Next) => (req: Req) => Promise<Res>;
type ResponseType = 'json' | 'arrayBuffer' | 'blob' | 'formData' | 'text' | null | false;
interface Progress {
    ratio: number;
    carry: number;
    total: number;
}
type ProgressCallback = (progress: Progress, chunk: Uint8Array) => void;
interface Options extends ReqInit {
    baseURL?: string;
    params?: Record<string, any>;
}

/**
 * Merge Headers
 * @param target target.headers
 * @param source source.headers
 * @returns headers
 */
declare const mergeHeaders: (target: HeadersInit | Headers, source: HeadersInit | Headers) => Headers;

declare class Resreq {
    options: Options;
    middleware: Middleware[];
    constructor(options?: Options);
    use(middleware: Middleware | Middleware[]): this;
    request<T = Res>(options: Options): Promise<T>;
    get<T = Res>(url: string, options?: Options): Promise<T>;
    post<T = Res>(url: string, options?: Options): Promise<T>;
    put<T = Res>(url: string, options?: Options): Promise<T>;
    delete<T = Res>(url: string, options?: Options): Promise<T>;
    patch<T = Res>(url: string, options?: Options): Promise<T>;
    head<T = Res>(url: string, options?: Options): Promise<T>;
}

export { Middleware, Next, Options, Progress, ProgressCallback, Req, ReqInit, Res, ResInit, ResponseType, Resreq as default, mergeHeaders };
